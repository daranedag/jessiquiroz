---
import { supabase } from "../db/supabase";

const { data, error } = await supabase
  .from("experience_items")
  .select("id, year, icon, title, description")
  .eq("is_published", true)
  .order("sort_order", { ascending: true })
  .order("year", { ascending: true });

const experienceItems = data ?? [];

if (error) {
  console.error("Supabase experience_items error:", error);
}
---

<section id="experiencias" class="bg-background-alt/40 py-16">
  <div class="mx-auto max-w-6xl px-6">
    <div class="text-center">
      <p class="text-xs font-semibold uppercase tracking-[0.3em] text-secondary">Experiencias de vida</p>
      <h2 class="font-display text-3xl text-text-main sm:text-4xl">Historias que inspiran</h2>
      <p class="mt-4 text-sm text-slate-600">Momentos clave que moldearon el enfoque hol√≠stico de la terapeuta.</p>
    </div>
    <div class="relative mt-12 overflow-hidden select-none cursor-grab touch-pan-y" data-carousel="experiencias">
      <div class="flex gap-8" data-carousel-track>
        {experienceItems.map((item) => (
          <article class="w-full shrink-0 rounded-3xl bg-white p-8 shadow-sm sm:w-1/2 lg:w-1/3" data-carousel-item>
            <h3 class="text-xl font-semibold">{item.title}</h3>
            <p class="mt-3 text-sm text-slate-600">{item.description}</p>
            <div class="mt-6 flex items-center gap-3 text-xs font-semibold uppercase tracking-[0.2em] text-primary">
              <span class="material-icons">{item.icon}</span>
              <span>{item.year}</span>
            </div>
          </article>
        ))}
      </div>
    </div>
  </div>
</section>

<script>
  const initExperiencesCarousel = () => {
    const carousel = document.querySelector<HTMLElement>('[data-carousel="experiencias"]');
    if (!carousel) return;

    const track = carousel.querySelector<HTMLElement>('[data-carousel-track]');
    if (!track) return;

    const originals = Array.from(track.querySelectorAll<HTMLElement>('[data-carousel-item]'));
    if (originals.length <= 1) return;

    const headClones = originals.map((item) => item.cloneNode(true) as HTMLElement);
    const tailClones = originals.map((item) => item.cloneNode(true) as HTMLElement);

    headClones.reverse().forEach((clone) => {
      clone.setAttribute('data-clone', 'true');
      track.prepend(clone);
    });

    tailClones.forEach((clone) => {
      clone.setAttribute('data-clone', 'true');
      track.append(clone);
    });

    const total = originals.length;
    let index = total;
    let intervalId = 0;
    let isAnimating = false;
    let isDragging = false;
    let startX = 0;
    let currentTranslate = 0;

    const getGap = () => parseFloat(getComputedStyle(track).gap || '0');
    const getItemWidth = () => originals[0].offsetWidth;

    const moveTo = (nextIndex: number, { animate = true }: { animate?: boolean } = {}) => {
      const gap = getGap();
      const width = getItemWidth();
      track.style.transition = animate ? 'transform 700ms ease-in-out' : 'none';
      track.style.transform = `translateX(-${nextIndex * (width + gap)}px)`;
      index = nextIndex;
      if (!animate) {
        requestAnimationFrame(() => {
          track.style.transition = 'transform 700ms ease-in-out';
        });
      }
    };

    const next = () => {
      if (isAnimating) return;
      isAnimating = true;
      moveTo(index + 1);
    };

    const prev = () => {
      if (isAnimating) return;
      isAnimating = true;
      moveTo(index - 1);
    };

    const startAuto = () => {
      stopAuto();
      intervalId = window.setInterval(next, 3500);
    };

    const stopAuto = () => {
      if (intervalId) {
        window.clearInterval(intervalId);
      }
    };

    const updateDragPosition = (clientX: number) => {
      const gap = getGap();
      const width = getItemWidth();
      const delta = clientX - startX;
      track.style.transition = 'none';
      track.style.transform = `translateX(${currentTranslate + delta}px)`;
    };

    const handleDragEnd = (clientX: number) => {
      const gap = getGap();
      const width = getItemWidth();
      const delta = clientX - startX;
      const threshold = (width + gap) * 0.2;
      track.style.transition = 'transform 700ms ease-in-out';

      if (delta < -threshold) {
        next();
      } else if (delta > threshold) {
        prev();
      } else {
        moveTo(index);
      }
    };

    track.addEventListener('transitionend', () => {
      if (index >= total * 2) {
        moveTo(total, { animate: false });
      } else if (index < total) {
        moveTo(total * 2 - 1, { animate: false });
      }
      isAnimating = false;
    });

    moveTo(index, { animate: false });
    startAuto();

    window.addEventListener('resize', () => moveTo(index, { animate: false }));
    carousel.addEventListener('mouseenter', stopAuto);
    carousel.addEventListener('mouseleave', startAuto);

    carousel.addEventListener('pointerdown', (event) => {
      isDragging = true;
      startX = event.clientX;
      stopAuto();
      const gap = getGap();
      const width = getItemWidth();
      currentTranslate = -(index * (width + gap));
      carousel.classList.add('cursor-grabbing');
      track.setPointerCapture?.(event.pointerId);
    });

    carousel.addEventListener('pointermove', (event) => {
      if (!isDragging) return;
      updateDragPosition(event.clientX);
    });

    const endDrag = (event: PointerEvent) => {
      if (!isDragging) return;
      isDragging = false;
      carousel.classList.remove('cursor-grabbing');
      handleDragEnd(event.clientX);
      startAuto();
    };

    carousel.addEventListener('pointerup', endDrag);
    carousel.addEventListener('pointerleave', endDrag);
    carousel.addEventListener('pointercancel', endDrag);
    carousel.addEventListener('dragstart', (event) => event.preventDefault());
  };

  initExperiencesCarousel();
</script>
