---
import { supabase } from "../db/supabase";

const { data, error } = await supabase
  .from("training_items")
  .select("id, category, icon, title, description")
  .eq("is_published", true)
  .order("sort_order", { ascending: true });

const trainingItems = data ?? [];

if (error) {
  console.error("Supabase training_items error:", error);
}
---

<section id="cursos" class="py-16">
  <div class="mx-auto max-w-7xl px-6">
    <div class="flex flex-col gap-6 md:flex-row md:items-end md:justify-between">
      <div>
        <p class="text-xs font-semibold uppercase tracking-[0.3em] text-secondary">Cursos y talleres realizados</p>
        <h2 class="font-display text-3xl text-text-main sm:text-4xl">Formación continua</h2>
        <p class="mt-3 text-sm text-slate-600">Trayectoria de aprendizajes que respaldan la práctica terapéutica.</p>
      </div>
    </div>
    <div class="relative mt-12 overflow-hidden select-none cursor-grab touch-pan-y" data-carousel>
      <div class="flex gap-8" data-carousel-track>
        {trainingItems.map((item) => (
          <article
            class="w-full shrink-0 rounded-3xl border border-primary/10 bg-white p-6 shadow-sm sm:w-1/2 lg:w-1/3"
            data-carousel-item
          >
            <div class="flex items-center justify-between">
              <span class="text-xs font-semibold uppercase tracking-[0.2em] text-primary">{item.category}</span>
              <span class="material-icons text-primary">{item.icon}</span>
            </div>
            <h3 class="mt-6 text-xl font-semibold">{item.title}</h3>
            <p class="mt-3 text-sm text-slate-600">{item.description}</p>
          </article>
        ))}
      </div>
    </div>
  </div>
</section>

<script>
  const carousel = document.querySelector<HTMLElement>("[data-carousel]");

  if (carousel) {
    const track = carousel.querySelector<HTMLElement>("[data-carousel-track]");

    if (track) {
      const originals = Array.from(track.querySelectorAll<HTMLElement>("[data-carousel-item]"));

      if (originals.length > 1) {
        const headClones = originals.map((item) => item.cloneNode(true) as HTMLElement);
        const tailClones = originals.map((item) => item.cloneNode(true) as HTMLElement);

        headClones.reverse().forEach((clone) => {
          clone.setAttribute("data-clone", "true");
          track.prepend(clone);
        });

        tailClones.forEach((clone) => {
          clone.setAttribute("data-clone", "true");
          track.append(clone);
        });

        const total = originals.length;
        let index = total;
        let intervalId = 0;
        let isAnimating = false;
        let isDragging = false;
        let startX = 0;
        let currentTranslate = 0;

        const getGap = () => parseFloat(getComputedStyle(track).gap || "0");
        const getItemWidth = () => originals[0].offsetWidth;

        const moveTo = (nextIndex: number, { animate = true }: { animate?: boolean } = {}) => {
          const gap = getGap();
          const width = getItemWidth();
          track.style.transition = animate ? "transform 700ms ease-in-out" : "none";
          track.style.transform = `translateX(-${nextIndex * (width + gap)}px)`;
          index = nextIndex;
          if (!animate) {
            requestAnimationFrame(() => {
              track.style.transition = "transform 700ms ease-in-out";
            });
          }
        };

        const next = () => {
          if (isAnimating) return;
          isAnimating = true;
          moveTo(index + 1);
        };

        const prev = () => {
          if (isAnimating) return;
          isAnimating = true;
          moveTo(index - 1);
        };

        const updateDragPosition = (clientX: number) => {
          const gap = getGap();
          const width = getItemWidth();
          const delta = clientX - startX;
          track.style.transition = "none";
          track.style.transform = `translateX(${currentTranslate + delta}px)`;
        };

        const handleDragEnd = (clientX: number) => {
          const gap = getGap();
          const width = getItemWidth();
          const delta = clientX - startX;
          const threshold = (width + gap) * 0.2;
          track.style.transition = "transform 700ms ease-in-out";

          if (delta < -threshold) {
            next();
          } else if (delta > threshold) {
            prev();
          } else {
            moveTo(index);
          }
        };

        const startAuto = () => {
          stopAuto();
          intervalId = window.setInterval(next, 3500);
        };

        const stopAuto = () => {
          if (intervalId) {
            window.clearInterval(intervalId);
          }
        };

        track.addEventListener("transitionend", () => {
          if (index >= total * 2) {
            moveTo(total, { animate: false });
          } else if (index < total) {
            moveTo(total * 2 - 1, { animate: false });
          }
          isAnimating = false;
        });

        moveTo(index, { animate: false });
        startAuto();

        window.addEventListener("resize", () => moveTo(index, { animate: false }));
        carousel.addEventListener("mouseenter", stopAuto);
        carousel.addEventListener("mouseleave", startAuto);

        carousel.addEventListener("pointerdown", (event: PointerEvent) => {
          isDragging = true;
          startX = event.clientX;
          stopAuto();
          const gap = getGap();
          const width = getItemWidth();
          currentTranslate = -(index * (width + gap));
          carousel.classList.add("cursor-grabbing");
          track.setPointerCapture?.(event.pointerId);
        });

        carousel.addEventListener("pointermove", (event: PointerEvent) => {
          if (!isDragging) return;
          updateDragPosition(event.clientX);
        });

        const endDrag = (event: PointerEvent) => {
          if (!isDragging) return;
          isDragging = false;
          carousel.classList.remove("cursor-grabbing");
          handleDragEnd(event.clientX);
          startAuto();
        };

        carousel.addEventListener("pointerup", endDrag);
        carousel.addEventListener("pointerleave", endDrag);
        carousel.addEventListener("pointercancel", endDrag);
        carousel.addEventListener("dragstart", (event) => event.preventDefault());
      }
    }
  }
</script>
